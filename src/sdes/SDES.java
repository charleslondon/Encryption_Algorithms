package sdes;

/**
 * A java implementation of the simplified
 * Data Encryption Standard algorithm.
 * 
 * @author Charles London
 * @author Erin Quigley
 * @author Matthew Paule
 */
public class SDES 
{
	private final boolean[] key;

	/**
	 * Default constructor.
	 */
	public SDES()
	{
		key = new boolean[]{false, false, false, false, 
				false, false, false, false, false, false};
	}

	/**
	 * Convert the given bit array to a single byte
	 * @param inp
	 * @return output, which is a Byte
	 */
	public byte bitArrayToByte(boolean[] inp)
	{
		byte output = 0;
		for(int i = 0; i < 8; i++)
		{
			if(inp[i])
			{
				output |= (byte)(1 << (7 - i));
			}
		}

		return output;
	}

	/**
	 * Convert the given byte array to a String
	 * @param inp
	 * @return String array
	 */
	public String byteArrayToString(byte[] inp)
	{
		StringBuilder s = new StringBuilder();
		for (byte b : inp) {
			s.append((char) b);
		}

		return s.toString();
	}

	/**
	 * Convert the given byte to a bit array, of the given size.
	 * @param b
	 * @return output, an Array of Bits
	 */
	public boolean[] byteToBitArray(byte b)
	{
		boolean[] output = new boolean[8];

		//use bitwise AND to isolate the value of each bit
		output[0] = ((b & 128) != 0);
		output[1] = ((b & 64) != 0);
		output[2] = ((b & 32) != 0);
		output[3] = ((b & 16) != 0);
		output[4] = ((b & 8) != 0);
		output[5] = ((b & 4) != 0);
		output[6] = ((b & 2) != 0);
		output[7] = ((b & 1) != 0);

		return output;
	}

	/**
	 *  Concatenate the two bit arrays, x || y
	 * @param x
	 * @param y
	 * @return output
	 */
	public boolean[] concat(boolean[] x, boolean[] y)
	{
		boolean[] output = new boolean[x.length + y.length];
		System.arraycopy(x, 0, output, 0, x.length); //copy x into the first half of output
		System.arraycopy(y, 0, output, x.length, y.length); //copy y into the second half of output

		return output;
	}

	/**
	 * Decrypt the given byte array.
	 * @param ciphertext, generated by encrypting the plain text
	 * @return plaintext
	 */

	public byte[] decrypt(byte[] ciphertext)
	{
		byte[] plaintext = new byte[ciphertext.length];

		for(int i = 0; i < ciphertext.length; i++)
		{
			plaintext[i] = decryptByte(ciphertext[i]);
		}

		return plaintext;
	}

	/**
	 * Decrypt a single byte using SDES
	 * @param b a single byte of the ciphertext
	 * @return bitArrayToByte(ciphertext), a single byte of plaintext
	 */

	public byte decryptByte(byte b)
	{
		//Step One - t <-- IP(x)
		int[] IP = {1, 5, 2, 0, 3, 7, 4, 6};
		boolean[] temp = expPerm(byteToBitArray(b), IP);

		//Step Two - t <-- fk2(t)	
		int[] k2 = {7, 2, 5, 4, 9, 1, 8, 0};
		boolean[] key2 = expPerm(key, k2);
		temp = f(temp, key2);

		//Step Three - t <-- swap(t)
		temp = swap(temp);

		//Step Four - t <-- fk1(t)
		int[] k1 = {0, 6, 8, 3, 7, 2, 9, 5};
		boolean[] key1 = expPerm(key, k1);
		temp = f(temp, key1);

		//Step Five - y <-- IP-1(t)
		int[] IP_Inverse = {3, 0, 2, 4, 6, 1, 7, 5};
		boolean[] ciphertext = expPerm(temp, IP_Inverse);


		return bitArrayToByte(ciphertext);
	}

	/**
	 * Encrypt the given string using SDES Each character produces a byte of cipher.
	 * @param msg, this is the plain text message entered by the user
	 * @return ciphertext
	 */
	public byte[] encrypt(String msg)
	{
		byte[] plaintext = msg.getBytes();
		byte[] ciphertext = new byte[plaintext.length];

		for(int i = 0; i < ciphertext.length; i++)
		{
			ciphertext[i] = encryptByte(plaintext[i]);
		}

		return ciphertext;
	}

	/**
	 * Encrypt a single byte using SDES
	 * @param b a single byte from the plaintext
	 * @return bitArrayToByte(ciphertext)
	 */
	public byte encryptByte(byte b)
	{
		//Step One - t <-- IP(x)
		int[] IP = {1, 5, 2, 0, 3, 7, 4, 6};
		boolean[] temp = expPerm(byteToBitArray(b), IP);

		//Step Two - t <-- fk1(t)
		int[] k1 = {0, 6, 8, 3, 7, 2, 9, 5};
		boolean[] key1 = expPerm(key, k1);
		temp = f(temp, key1);

		//Step Three - t <-- swap(t)
		temp = swap(temp);

		//Step Four - t <-- fk2(t)
		int[] k2 = {7, 2, 5, 4, 9, 1, 8, 0};
		boolean[] key2 = expPerm(key, k2);
		temp = f(temp, key2);

		//Step Five - y <-- IP-1(t)
		int[] IP_Inverse = {3, 0, 2, 4, 6, 1, 7, 5};
		boolean[] ciphertext = expPerm(temp, IP_Inverse);


		return bitArrayToByte(ciphertext);
	}

	/**
	 * Expand and/or permute and/or select from the bit array, inp, producing an 
	 * expanded/permuted/selected bit array. Use the expansion/permutation vector epv.
	 * @param inp
	 * @param epv
	 * @return output
	 */
	public boolean[] expPerm(boolean[] inp, int[] epv)
	{	
		boolean[] output = new boolean[epv.length];

		for(int position = 0; position < epv.length; position++)
		{
			output[position] = inp[epv[position]];
		}

		return output;
	}

	/**
	 * This is the 'round' function. It is its own inverse. 
	 * f(x,k) = (L(x) xor F(R(x), k)) || R(x)
	 * @param x
	 * @param k
	 * @return output
	 */
	public boolean[] f(boolean[] x, boolean[] k)
	{
		boolean[] left = lh(x);
		boolean[] right = rh(x);
		boolean[] output = xor(left, feistel(k, right));
		output = concat(output, right);

		return output;
	}

	/**
	 *  F(k,x) is a Feistel function.
	 *  F(k,x) = P4(s0(L(k xor EP(x))) || s1(R(k xor EP(x)))
	 * @param k
	 * @param x
	 * @return output
	 */
	public boolean[] feistel(boolean[] k, boolean[] x)
	{
		int[] EP = {3, 0, 1, 2, 1, 2, 3, 0};
		int[] P4 = {1, 3, 2, 0};

		//S-boxes' values from example from the textbook
		//Placed in a specific order so we can easily access
		//the correct values based on the decimal value of
		//L(k xor EP(x)) and R(k xor EP(x))
		boolean[][] s0 = {{false,true},  {true,true},  {false,false}, {true,false},
				{true,true},   {false,true}, {true,false},  {false,false}, 
				{false,false}, {true,true},  {true,false},  {false,true}, 
				{false,true},  {true,true},  {true,true},   {true,false}};

		boolean[][] s1 = {{false,false}, {true,false},  {false,true},  {false,false},
				{true,false},  {false,true},  {true,true},   {true,true}, 
				{true,true},   {true,false},  {false,false}, {false,true}, 
				{false,true},  {false,false}, {false,false}, {true,true}};

		boolean[] temp = expPerm(x, EP);
		temp = xor(temp, k);
		boolean[] tempLeft = lh(temp);
		boolean[] tempRight = rh(temp);

		tempLeft = s0[BinaryToDecimal(tempLeft)];
		tempRight = s1[BinaryToDecimal(tempRight)];

		temp = concat(tempLeft, tempRight);

		return expPerm(temp, P4);
	}


	/** 
	 * Gets boolean array as arguments and returns an equal value decimal number. 
	 * for example input [false, true, false] will return 2  
	 **/ 
	private int BinaryToDecimal(boolean[] bits)
	{
		int temp = 0;
		int base = 1;

		for(int i = bits.length - 1; i >= 0; i--)
		{
			int value = bits[i] ? 1 : 0;
			temp = temp + (value * base);
			base = base * 2 ;
		}

		return temp;
	}

	/**
	 *  Get a 10 bit key from the keyboard, such as 1010101010. 
	 *  Store it as an array of booleans in a field.
	 * @param scanner
	 */
	public void getKey10(java.util.Scanner scanner)
	{
		System.out.println("Please enter your 10-bit key: ");
		String temp = scanner.nextLine(); //add filters for bad input later?

		for(int i = 0; i < key.length; i++)
		{
			if(temp.charAt(i) == '0')
			{
				key[i] = false;
			}
			else if(temp.charAt(i) == '1')
			{
				key[i] = true;
			}
		}
	}

	/**
	 *  Get a 10 bit key from the keyboard, such as 1010101010. 
	 *  Store it as an array of booleans in a field.
	 */
	public void getKey10(String input)
	{	
		for(int i = 0; i < 10; i++)
		{
			if(input.charAt(i) == '0')
			{
				key[i] = false;
			}
			else if(input.charAt(i) == '1')
			{
				key[i] = true;
			}
		}
	}

	/**
	 * Left half of x, L(x)
	 * @param inp
	 * @return output
	 */
	public boolean[] lh(boolean[] inp)
	{
		int position = inp.length / 2;
		boolean[] output = new boolean[position];
		System.arraycopy(inp, 0, output, 0, position);

		return output;
	}

	/**
	 * Right half of x, R(x)
	 * @param inp
	 * @return output
	 */
	public boolean[] rh(boolean[] inp)
	{
		int position = inp.length / 2;
		boolean[] output = new boolean[position];
		System.arraycopy(inp, position, output, 0, position);

		return output;
	}

	/**
	 * Send the bitArray to stdout as 1's and 0's
	 * @param inp
	 */
	public void show(boolean[] inp)
	{
		int value;
		for(boolean output : inp)
		{
			if(output)
			{
				value = 1;
			}
			else
			{
				value = 0;
			}

			System.out.print(value);
		}
	}

	/**
	 * Send the byteArray to stdout
	 * @param byteArray
	 */
	public void show(byte[] byteArray)
	{
		for(byte output : byteArray)
		{
			show(byteToBitArray(output));
			System.out.print(" ");
		}
	}

	/**
	 * Exclusive OR. x and y must have the same length (4 bits). 
	 * x XOR y is the same as x != y
	 * @param x
	 * @param y
	 * @return z
	 */
	public boolean[] xor(boolean[] x, boolean[] y)
	{
		boolean[] z = new boolean[x.length];

		for(int i = 0; i < x.length; i++)
		{
			z[i] = x[i] != y[i];
		}

		return z;
	}

	/**
	 * Swap the nibbles of the array.
	 * @param input
	 * @return input
	 */
	public boolean[] swap(boolean[] input)
	{
		for(int i = 0; i < input.length / 2; i++)
		{
			boolean temp = input[i];
			input[i] = input[(input.length / 2) + i];
			input[(input.length / 2) + i] = temp;
		}

		return input;
	}
}